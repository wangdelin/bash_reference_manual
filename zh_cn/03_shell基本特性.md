03 shell基本特性
================

3.1 shell语法
-------------

### 3.1.1 shell操作

以下是shell读取和执行命令时的操作的简要说明。 基本上，shell执行以下操作：

1. 从文件中(查看3.8 shell脚本)，从作为参数提供给-c选项(查看6.1 调用Bash)的字符串中，或者从用户终端读取输入。
2. 将输入拆分为词和操作符，遵循引用章节中描述的引用规则。这些token由元字符分隔。在该步骤alias扩展被执行(查看6.6 Alias)。
3. 解析上述token为简单和复合的命令(查看3.2 shell命令)。
4. 执行各种shell扩展(查看3.5 shell扩展)，将这些扩展过的token分解到文件名(查看3.5.8 文件名扩展)、命令、参数列表中。
5. 执行任何必要的重定向(查看3.6 重定向)并且从参数列表中删除重定向操作符及其操作数。
6. 执行命令(查看3.7 执行命令)。
7. 可选，等待命令完成并收集其退出状态(查看3.7.5 退出状态)。

### 3.1.2 引用

引用用于删除某些字符或单词对shell的特殊含义。引用可用于禁止特殊字符的特殊处理，以防止保留字被识别，并防止参数扩展。

每个shell的元字符(查看02. 定义)对shell有特殊的含义，如果要表示自身，必须引用它。当命令历史扩展技术被使用时(查看9.3 历史扩展)，历史扩展字符(通常是'!'), 必须被引用以保护历史扩展。查看9.1 Bash历史技术，了解更多关于历史扩展的内容。

有3种引用机制: 转义字符，单引号和双引号。

#### 3.1.2.1 转义字符

'\' 不带引号的反斜杠是Bash的转义字符。它保留下一个字符的字面值，除了换行以外。如果\newline对出现，反斜杆本身不会被引用，\newline被视为一行延续(也就是说，它被从输入流中移除并被有效的忽略)。

#### 3.1.2.2 单引号

单引号('')可保留引号内每个字符的字面值。单引号不能放在单引号之间，即使是加了反斜杆也不行。

#### 3.1.2.3 双引号

双引号("")可保留引号内所有字符的字面值，除了以下字符以外，'$', '\`', '\', 以及开启历史扩展以后的'!'字符。当shell在POSIX模式时(查看6.11 Bash POSIX模式), 双引号里面的'!'没有特殊的意义，即使开启了历史扩展。双引号内的'$', '\`'字符保留其特殊含义(查看3.5 shell扩展)。反斜杆字符'\\'仅在后面跟'$', '\`', '"', '\\', 或换行时有特殊意义。在双引号内部，后面跟上述的这些字符的反斜杆会被移除。前面没有特殊含义字符的反斜杆会被保持不变。双引号内前面有反斜杆的双引号可以能被引用。如果历史扩展启用，那么它将被执行，除非使用反斜杠转义双引号中的"!"。"!"之前的反斜杠不会被删除。

在双引号中，特殊参数 '*' 和 '@' 有特殊的含义(查看3.5.3 shell参数扩展)。

#### 3.1.2.4 ANSI-C引用

$'string'形式的词会被特殊处理，它会被扩展为string，反斜杠转义的字符按ANSI C标准替换。反斜杠转义序列（如果存在）按照如下解码：

转义字符   | 说明
-----------|------------
\a         | 警告(响铃)
\b         | 退格
\e \E      | 一个转义字符(非ANSI C)
\f         | 换页
\n         | 换行
\r         | 回车
\t         | 水平制表符
\v         | 垂直制表符
\\\\       | 反斜杠
\'         | 单引号
\"         | 双引号
\?         | 问号
\nnn       | 值为八进制nnn表示的八位字符(1到3位八进制数)
\xHH       | 值为十六进制HH表示的八位字符(1到2位十六进制数)
\uHHHH     | 值为十六进制HHHH的Unicode(ISO/IEC 10646)的字符(1到4位十六进制数)
\UHHHHHHHH | 值为十六进制HHHHHHHH的Unicode(ISO/IEC 10646)的字符(1到8位十六进制数)
\cx        | control-x字符

扩展结果是被单引号的，就如'$'符号没有出现一样。

#### 3.1.2.5 特定区域翻译

双引号内的字符串前面加上'$'标志，会导致该字符串根据当前的locale来翻译。如果locale为C或者POSIX，那么'$'标志会被忽略。如果字符串被翻译和替代，该替代是双引号的。

一些系统使用由LC_MESSAGES shell变量选择的消息目录。其他一些通过shell变量TEXTDOMAIN来创建消息目录的名称，可能添加'.mo'后缀。如果你使用TEXTDOMAIN变量，你可能需要设置TEXTDOMAINDIR变量为消息目录文件的位置。另外也有一些同时使用这两种方式: TEXTDOMAINDIR/LC_MESSAGES/LC_MESSAGES/TEXTDOMAIN.mo。

### 3.1.3 注释

在非交互shell，或者`shopt`内置命令(查看 4.3.2 shopt内置命令)设置了interactive_comments选项的交互shell中，以"#"字符开头会导致该行上的所有字符被忽略。没有开启interactive_comments选项的交互shell不允许注释。交互shell中interactive_comments选项是默认开启的。查看6.3 交互shell，了解有关交互shell的描述。

3.2 shell命令
-------------

一个简单的shell命令(如 echo a b c)，由命令本身及后跟空格分隔的参数组成。

更复杂的shell命令由简单命令以各种方式排列在一起组成：用管道的方式(一个命令的输出变成另一个命令的输入)，用循环或条件结构的方式，或者用一些其他组织形式。

### 3.2.1 简单命令

简单命令是最常见的一种命令。它只是一个由空白分隔的词序列，并且由一个shell控制符(查看02 定义)终止。第一个词通常指定要执行的命令，其余的词是该命令的参数。

简单命令的返回状态(查看3.7.5 退出状态)是由POSIX 1003.1 `waitpid`函数提供的退出状态，或者如果命令被n信号终止，则为128+n。

### 3.2.2 管道

管道是以控制符'|'或'|&'之一分隔的一个或多个命令的序列。

管道的格式如下

```bash

[time [-p]] [!] command1 [ | or |& command2 ] ...
```

管道中的每个命令的输出通过管道连接到下一个命令的输入。也就是，每个命令读取前一个命令的输出。此连接在指令指定的任何重定向之前执行。

如果使用'|&'， 除了标准输出之外，command1的标准错误也会通过管道连接到command2的标准输入。这是`2>＆1 |`的缩写。标准错误到标准输出的这种隐式重定向在命令指定的任何重定向之后执行的。

保留字`time`可以在管道完成的时候打印它的计时统计信息。当前的统计数据包含命令执行所花费的实际耗时、用户耗时、系统耗时。-p选项将输出格式更改为POSIX指定的格式。当shell处于POSIX模式（参见6.11 Bash POSIX模式）时，如果下一个标记以"-"开头，则它不会将`time`识别为保留字。TIMEFORMAT变量用于设置时间信息显示的格式。查看5.2 Bash变量，了解可用的时间格式的描述。`time`可用于shell内置命令、shell函数和管道。外部的`time`不能这么轻易的计时。

当shell处于POSIX模式时（参见Bash POSIX模式），`time`可以后跟一个换行符。在这种情况下，shell会显示shell及其子项所消耗的总用户和系统时间。TIMEFORMAT变量可用于指定时间信息的格式。

如果管道不是异步执行（参见3.2.3 列表），则shell将等待管道中的所有命令完成。

每个管道中的命令都是在它自己的子shell中执行（参见3.7.3 命令执行环境）。除非启用pipefail选项（参见4.3.1 set内置命令），否则管道的退出状态是管道中最后一个命令的退出状态。如果启用pipefail选项，管道的返回状态是以非零状态退出的最后（最右边）命令的值，如果所有命令都成功退出，则为零。如果保留字'!'在管道之前，则退出状态是如上所述的退出状态的逻辑否定。shell在返回值之前等待管道中的所有命令终止。

### 3.2.3 列表

列表是以';', '&', '&&', 或'||'之一分割的一个或多个管道的序列。可选的，以';', '&', 或换行之一终止。

在这些列表运算符中， '&&' 和 '||' 具有相同优先级，';' 和 '&' 具有相同优先级，前面两个运算符的优先级高于后者。

一个或多个换行序列可能出现在列表中，它相当于分号。

如果命令被控制运算符'&'终止，那么shell将在子shell中异步执行该命令。这被称为在后台执行命令。shell不等待该命令执行完成，并且它的返回状态是0(true)。当Job控制处于非活动状态（参见07. Job控制），对异步命令的标准输入，在没有任何明确的重定向的，是从/dev /null的重定向。

按';'分隔的命令将依次执行。shell等待每个命令依次终止。返回状态是最后执行命令的退出状态。

AND和OR列表是分别被控制运算符'&&'和'||'分割的一个或多个管道的序列，AND和OR列表以左关联方式执行。

AND列表的形式

```bash

command1 && command2
```

只有当command1返回退出状态为0时，command2才被执行。

OR列表的形式

```bash

command1 || command2
```

AND和OR列表的返回状态是列表中最后执行命令的退出状态。

只有当command1返回退出状态为非零时，command2才被执行。

### 3.2.4 复合命令

复合命令是shell的编程结构。每个构造以保留字或控制运算符开头，并由相应的保留字或运算符终止。与复合命令相关联的任何重定向（参见3.6 重定向）适用于该复合命令中的所有命令，除非明确覆盖。

在大多数情况下，复合命令中的命令列表可以被一个或者多个换行符分开，也可以用后跟换行符来替代分号。

Bash提供循环结构，条件结构，以及以一个单元来分组命令和执行命令的机制。

#### 3.2.4.1 循环结构

Bash提供以下几种循环结构。

> **请注意:**

> - 无论分号';'出现在命令语法描述的什么地方，它都可以用一个或者多个换行代替。

- until

`until`命令的语法是

```bash

until test-commands; do consequent-commands; done
```

只要test-commands的退出状态不为零，就循环执行consequent-commands。返回状态是consequent-commands中最后执行命令的退出状态，如果没有任何命令被执行，则返回0。

- while

`while`命令的语法是

```bash

while test-commands; do consequent-commands; done
```

只要test-commands的退出状态为零，就循环执行consequent-commands。返回状态是consequent-commands中最后执行命令的退出状态，如果没有任何命令被执行，则返回0。

- for

`for`命令的语法是

```bash

for name [ [in [words …] ] ; ] do commands; done
```

展开words, 并在结果列表中为每个成员执行commands，其中name绑定到当前成员。如果'in words'不存在，那么`for`命令为每个位置参数执行commands，就如同指定了'in "$@"'一样（查看3.4.2 位置参数）。返回状态是执行的最后一个命令的退出状态。如果words中没有任何项目，则不执行任何命令，并且返回状态为零。

`for`命令支持的另一种形式是:

```bash

for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
```

首先，算术运算表达式expr1按照下面的规则执行（查看6.5 shell算术运算）。然后，重复计算算术表达式expr2直到其计算为0。每一次expr2求值为非零，则执行commands并对算术表达式expr3求值。如果省略任何表达式，就如同它的求值为1一样。其返回值是commands中执行的最后一个命令的退出状态，如果任何表达式无效，则返回false。

#### 3.2.4.2 条件结构

#### 3.2.4.3 分组命令

### 3.2.5 协进程

### 3.2.6 GNU并行

3.3 shell函数
-------------

3.4 shell参数
-------------

参数是存储值的实体。它可以是一个名称，数字，或下面列出来的特殊字符。变量是一个有名称标识的参数。变量有一个值及零个或多个属性。属性是通过`declare`内置命令分配的（查看4.2 Bash内置命令查看`declare`的描述）。

如果参数分配了值，那么它就被设置了。空字符串是一个有效的值。一旦变量被设置，它仅可通过内置命令`unset`来删除。

变量可以通过下面语句的形式来赋值

```bash

name=[value]
```

如果value没有给定，这个变量会被分配一个空字符串。 所有值包括波浪号扩展，参数和变量扩展，命令替换，算术扩展，和引用输出(详细如下)。如果变量设置了整数属性，那么即使不使用$((...))扩展，变量的值也会被作为算术表达式进行计算（查看3.55 算术扩展）。词分割不会被执行，除了下面解释的"$@"。文件名扩展不执行。赋值语句也可以以参数的形式出现在`alias`, `declare`, `typeset`, `export`, `readonly`和`local`内置命令(声明命令)。当在POSIX模式下(查看6.11 Bash POSIX模式)，这些内置命令也可以出现在内置命令`command`的一个或多个实例之后的命令中并保留这些赋值语句属性。

在赋值语句将一个值分配给shell变量或者数组索引(查看6.7 数组)，'+='操作符用于附加或者加到该变量的前一个值。它包含如接受赋值语句的`declare`内置命令（声明命令）的参数。当将'+ ='应用于已设置整数属性的变量时，将值作为算术表达式计算，并添加到变量的当前值中，该值也被计算。当将'+='应用于复合赋值（查看6.7 数组）的数组变量时，变量的值不是未设置的（因为它使用了'='），新值将插入到数组（索引数组）的最大索引值之后， 或作为附加键值对添加到关联数组中。当它应用于字符串型变量时，值将被扩展并附加到该变量的值。

使用带-n选项内置命令`declare`或`local`命令（查看4.2 Bash内置命令）为变量分配'nameref'属性来创建一个nameref, 或引用另一个变量。它允许变量被间接操作。无论nameref变量被引用，被分配，被删除，或属性被修改(除了使用或修改nameref属性本身)，该操作实际上是对nameref变量值指定变量的操作。nameref常用于函数内部来引用以参数传递给函数的变量。例如，如果将变量名作为第一个参数传递给函数，则运行

```bash

declare -n ref=$1
```

函数内部创建一个nameref变量ref，其值是第一个参数的变量名。引用和给ref赋值，或改变它的属性，被视为是对$1的操作。

如果for循环中的控制变量具有nameref属性，列表可以是一个shell变量列表， 并且当循环执行时，将顺序的为列表中的每个元素建立名称引用。数组变量不能被分配nameref属性。然而nameref变量可以引用数组变量和下标数组变量。nameref可以使用内置命令`unset`（查看4.1 Bourne Shell内置命令）的-n选项删除。否则，如果不加-n选项，被nameref变量引用的变量也将会被删除。

### 3.4.1 位置参数

位置参数是除了0以外的一个或者多个数字表示的参数。位置参数在shell的参数被调用时分配，并且可以使用`set`内置命令重新分配。位置参数N可以以${N}的形式引用，当N为单个数字时可以简写为$N。位置参数不能分配给赋值语句。内置命令`set`和`shift`用于设置和删除它们（查看4 shell内置命令）。当shell函数执行时，位置参数会被临时替换（查看3.3 shell函数）。

当位置参数由多个单个数字组成时，它必须用大括号括起来。

### 3.4.2 特殊参数

shell有几个特殊参数。这些参数只能被引用，不允许被赋值。

- \*

($*) 从第一个开始展开位置参数。当扩展不在双引号内，每个位置参数扩展为一个单独的词。在该参数执行的地方，这些位置参数将进一步的词分割和路径名扩展。当扩展在双引号内，它将被扩展为以特殊变量IFS的第一个字符分割的每个参数的值的单独词。也就是说，"$*"相当于"$1c$2c..."，其中c是变量IFS值的第一个字符。如果IFS没有设置，那么参数会被空白分割。如果IFS为空，会在没有中间分隔器的情况下连接参数。

- @

($@) 从第一个开始展开位置参数。当扩展在双引号内时，每个位置参数扩展为一个单独的词。也就是说，"$@" 相当于"$1" "$2" ...。如果元素内发生双引号扩展，第一个参数的扩展与原始单词的开始部分相结合， 最后一个参数的扩展与元素单词的最后部分相结合。当没有位置参数时，"$@"和$@被扩展为空（即它们被移除）。

- \#

($#) 扩展为位置参数的个数

- ?

($?) 扩展为最近执行的前台管道的退出状态。

- \-

($-, 连字符) 扩展为调用时指定的当前选项标志，有`set`内置命令或者由shell本身设置的选项标志(例如 -i 选项)。

- $

($$) 扩展为shell的进程ID。在()子shell中，它扩展为调用shell的进程ID，而不是子shell。

- !

($!) 扩展为最近置于后台执行的Job进程ID，无论这个Job是通过异步命令还是内置的`bg`命令(查看 7.2 Job控制内置命令)。

- 0

($0) 扩展为shell的名称或者shell脚本的名称。这是在shell初始化的时候设置的。如果Bash是被shell脚本调用(查看 3.8 shell脚本)，$0表示这个脚本的名称。如果Bash是以-c选项启动(查看 6.1 调用Bash)，那么$0被设置为执行字符串后的第一个参数，如果它存在。否则，它被设置为由参数0给出的用于调用Bash的文件名。

- _

($_, 下划线) 在shell启动时，设置为用于调用正在环境或参数列表中传递的shell或shell脚本的绝对路径名。然后，扩展后，扩展为上一个命令的最后一个参数。还设置为用于调用执行并放置在导出到该命令的环境中的每个命令的完整路径名。检查邮件时，此参数保存邮件文件的名称。


3.5 shell扩展
-------------

3.6 重定向
----------

3.7 执行命令
------------

3.8 shell脚本
-------------
