03 shell基本特性
================

3.1 shell语法
-------------

### 3.1.1 shell操作

以下是shell读取和执行命令时的操作的简要说明。 基本上，shell执行以下操作：

1. 从文件中(查看3.8 shell脚本)，从作为参数提供给-c选项(查看6.1 调用Bash)的字符串中，或者从用户终端读取输入。
2. 将输入拆分为词和操作符，遵循引用章节中描述的引用规则。这些token由元字符分隔。在该步骤alias扩展被执行(查看6.6 Alias)。
3. 解析上述token为简单和复合的命令(查看3.2 shell命令)。
4. 执行各种shell扩展(查看3.5 shell扩展)，将这些扩展过的token分解到文件名(查看3.5.8 文件名扩展)、命令、参数列表中。
5. 执行任何必要的重定向(查看3.6 重定向)并且从参数列表中删除重定向操作符及其操作数。
6. 执行命令(查看3.7 执行命令)。
7. 可选，等待命令完成并收集其退出状态(查看3.7.5 退出状态)。

### 3.1.2 引用

引用用于删除某些字符或单词对shell的特殊含义。引用可用于禁止特殊字符的特殊处理，以防止保留字被识别，并防止参数扩展。

每个shell的元字符(查看02. 定义)对shell有特殊的含义，如果要表示自身，必须引用它。当命令历史扩展技术被使用时(查看9.3 历史扩展)，历史扩展字符(通常是'!'), 必须被引用以保护历史扩展。查看9.1 Bash历史技术，了解更多关于历史扩展的内容。

有3种引用机制: 转义字符，单引号和双引号。

#### 3.1.2.1 转义字符

'\\' 不带引号的反斜杠是Bash的转义字符。它保留下一个字符的字面值，除了换行以外。如果\newline对出现，反斜杆本身不会被引用，\newline被视为一行延续(也就是说，它被从输入流中移除并被有效的忽略)。

#### 3.1.2.2 单引号

单引号('')可保留引号内每个字符的字面值。单引号不能放在单引号之间，即使是加了反斜杆也不行。

#### 3.1.2.3 双引号

双引号("")可保留引号内所有字符的字面值，除了以下字符以外，'$', '\`', '\', 以及开启历史扩展以后的'!'字符。当shell在POSIX模式时(查看6.11 Bash POSIX模式), 双引号里面的'!'没有特殊的意义，即使开启了历史扩展。双引号内的'$', '\`'字符保留其特殊含义(查看3.5 shell扩展)。反斜杆字符'\\'仅在后面跟'$', '\`', '"', '\\', 或换行时有特殊意义。在双引号内部，后面跟上述的这些字符的反斜杆会被移除。前面没有特殊含义字符的反斜杆会被保持不变。双引号内前面有反斜杆的双引号可以能被引用。如果历史扩展启用，那么它将被执行，除非使用反斜杠转义双引号中的"!"。"!"之前的反斜杠不会被删除。

在双引号中，特殊参数 '*' 和 '@' 有特殊的含义(查看3.5.3 shell参数扩展)。

#### 3.1.2.4 ANSI-C引用

$'string'形式的词会被特殊处理，它会被扩展为string，反斜杠转义的字符按ANSI C标准替换。反斜杠转义序列（如果存在）按照如下解码：

转义字符   | 说明
-----------|------------
\a         | 警告(响铃)
\b         | 退格
\e \E      | 一个转义字符(非ANSI C)
\f         | 换页
\n         | 换行
\r         | 回车
\t         | 水平制表符
\v         | 垂直制表符
\\\\       | 反斜杠
\'         | 单引号
\"         | 双引号
\?         | 问号
\nnn       | 值为八进制nnn表示的八位字符(1到3位八进制数)
\xHH       | 值为十六进制HH表示的八位字符(1到2位十六进制数)
\uHHHH     | 值为十六进制HHHH的Unicode(ISO/IEC 10646)的字符(1到4位十六进制数)
\UHHHHHHHH | 值为十六进制HHHHHHHH的Unicode(ISO/IEC 10646)的字符(1到8位十六进制数)
\cx        | control-x字符

扩展结果是被单引号的，就如'$'符号没有出现一样。

#### 3.1.2.5 特定区域翻译

双引号内的字符串前面加上'$'标志，会导致该字符串根据当前的locale来翻译。如果locale为C或者POSIX，那么'$'标志会被忽略。如果字符串被翻译和替代，该替代是双引号的。

一些系统使用由LC_MESSAGES shell变量选择的消息目录。其他一些通过shell变量TEXTDOMAIN来创建消息目录的名称，可能添加'.mo'后缀。如果你使用TEXTDOMAIN变量，你可能需要设置TEXTDOMAINDIR变量为消息目录文件的位置。另外也有一些同时使用这两种方式: TEXTDOMAINDIR/LC_MESSAGES/LC_MESSAGES/TEXTDOMAIN.mo。

### 3.1.3 注释

在非交互shell，或者`shopt`内置命令(查看 4.3.2 shopt内置命令)设置了interactive_comments选项的交互shell中，以"#"字符开头会导致该行上的所有字符被忽略。没有开启interactive_comments选项的交互shell不允许注释。交互shell中interactive_comments选项是默认开启的。查看6.3 交互shell，了解有关交互shell的描述。

3.2 shell命令
-------------

一个简单的shell命令(如`echo a b c`)，由命令本身及后跟空格分隔的参数组成。

更复杂的shell命令由简单命令以各种方式排列在一起组成：用管道的方式(一个命令的输出变成另一个命令的输入)，用循环或条件结构的方式，或者用一些其他组织形式。

### 3.2.1 简单命令

简单命令是最常见的一种命令。它只是一个由空白分隔的词序列，并且由一个shell控制符(查看02 定义)终止。第一个词通常指定要执行的命令，其余的词是该命令的参数。

简单命令的返回状态(查看3.7.5 退出状态)是由POSIX 1003.1 `waitpid`函数提供的退出状态，或者如果命令被n信号终止，则为128+n。

### 3.2.2 管道

管道是以控制符'|'或'|&'之一分隔的一个或多个命令的序列。

管道的格式如下

```bash

[time [-p]] [!] command1 [ | or |& command2 ] ...
```

管道中的每个命令的输出通过管道连接到下一个命令的输入。也就是，每个命令读取前一个命令的输出。此连接在指令指定的任何重定向之前执行。

如果使用'|&'， 除了标准输出之外，command1的标准错误也会通过管道连接到command2的标准输入。这是`2>＆1 |`的缩写。标准错误到标准输出的这种隐式重定向在命令指定的任何重定向之后执行的。

保留字`time`可以在管道完成的时候打印它的计时统计信息。当前的统计数据包含命令执行所花费的实际耗时、用户耗时、系统耗时。-p选项将输出格式更改为POSIX指定的格式。当shell处于POSIX模式（参见6.11 Bash POSIX模式）时，如果下一个标记以"-"开头，则它不会将`time`识别为保留字。TIMEFORMAT变量用于设置时间信息显示的格式。查看5.2 Bash变量，了解可用的时间格式的描述。`time`可用于shell内置命令、shell函数和管道。外部的`time`不能这么轻易的计时。

当shell处于POSIX模式时（参见Bash POSIX模式），`time`可以后跟一个换行符。在这种情况下，shell会显示shell及其子项所消耗的总用户和系统时间。TIMEFORMAT变量可用于指定时间信息的格式。

如果管道不是异步执行（参见3.2.3 列表），则shell将等待管道中的所有命令完成。

每个管道中的命令都是在它自己的子shell中执行（参见3.7.3 命令执行环境）。除非启用pipefail选项（参见4.3.1 set内置命令），否则管道的退出状态是管道中最后一个命令的退出状态。如果启用pipefail选项，管道的返回状态是以非零状态退出的最后（最右边）命令的值，如果所有命令都成功退出，则为零。如果保留字'!'在管道之前，则退出状态是如上所述的退出状态的逻辑否定。shell在返回值之前等待管道中的所有命令终止。

### 3.2.3 列表

列表是以';', '&', '&&', 或'||'之一分割的一个或多个管道的序列。可选的，以';', '&', 或换行之一终止。

在这些列表运算符中， '&&' 和 '||' 具有相同优先级，';' 和 '&' 具有相同优先级，前面两个运算符的优先级高于后者。

一个或多个换行序列可能出现在列表中，它相当于分号。

如果命令被控制运算符'&'终止，那么shell将在子shell中异步执行该命令。这被称为在后台执行命令。shell不等待该命令执行完成，并且它的返回状态是0(true)。当Job控制处于非活动状态（参见07. Job控制），对异步命令的标准输入，在没有任何明确的重定向的，是从/dev /null的重定向。

按';'分隔的命令将依次执行。shell等待每个命令依次终止。返回状态是最后执行命令的退出状态。

AND和OR列表是分别被控制运算符'&&'和'||'分割的一个或多个管道的序列，AND和OR列表以左关联方式执行。

AND列表的形式

```bash

command1 && command2
```

只有当command1返回退出状态为0时，command2才被执行。

OR列表的形式

```bash

command1 || command2
```

AND和OR列表的返回状态是列表中最后执行命令的退出状态。

只有当command1返回退出状态为非零时，command2才被执行。

### 3.2.4 复合命令

复合命令是shell的编程结构。每个构造以保留字或控制运算符开头，并由相应的保留字或运算符终止。与复合命令相关联的任何重定向（参见3.6 重定向）适用于该复合命令中的所有命令，除非明确覆盖。

在大多数情况下，复合命令中的命令列表可以被一个或者多个换行符分开，也可以用后跟换行符来替代分号。

Bash提供循环结构，条件结构，以及以一个单元来分组命令和执行命令的机制。

#### 3.2.4.1 循环结构

Bash提供以下几种循环结构。

> **请注意:**

> - 无论分号';'出现在命令语法描述的什么地方，它都可以用一个或者多个换行代替。

- until

`until`命令的语法是

```bash

until test-commands; do consequent-commands; done
```

只要test-commands的退出状态不为零，就循环执行consequent-commands。返回状态是consequent-commands中最后执行命令的退出状态，如果没有任何命令被执行，则返回0。

- while

`while`命令的语法是

```bash

while test-commands; do consequent-commands; done
```

只要test-commands的退出状态为零，就循环执行consequent-commands。返回状态是consequent-commands中最后执行命令的退出状态，如果没有任何命令被执行，则返回0。

- for

`for`命令的语法是

```bash

for name [ [in [words …] ] ; ] do commands; done
```

展开words, 并在结果列表中为每个成员执行commands，其中name绑定到当前成员。如果'in words'不存在，那么`for`命令为每个位置参数执行commands，就如同指定了'in "$@"'一样（查看3.4.2 位置参数）。返回状态是执行的最后一个命令的退出状态。如果words中没有任何项目，则不执行任何命令，并且返回状态为零。

`for`命令支持的另一种形式是:

```bash

for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
```

首先，算术运算表达式expr1按照下面的规则执行（查看6.5 shell算术运算）。然后，重复计算算术表达式expr2直到其计算为0。每一次expr2求值为非零，则执行commands并对算术表达式expr3求值。如果省略任何表达式，就如同它的求值为1一样。其返回值是commands中执行的最后一个命令的退出状态，如果任何表达式无效，则返回false。

#### 3.2.4.2 条件结构

- if

`if`命令的语法如下:

```bash

if test-commands; then
  consequent-commands;
[elif more-test-commands; then
  more-consequents;]
[else alternate-consequents;]
fi
```

如果test-commands命令列表执行的返回状态是0，consequent-commands命令列表则会被执行。如果test-commands返回非零状态，依次执行每个elif列表，如果其退出状态为零，则执行相应的more-consequents并且命令完成。如果'else alternate-consequents'存在，并且最后的if或elif返回一个非零的状态，那么'alternate-consequents'会被执行。其返回状态是执行的最后一个命令的退出状态，如果没有条件测试为true，则返回0。

- case

`case`命令的语法如下:

```bash

case word in [ [(] pattern [| pattern]…) command-list ;;]… esac
```

`case`将根据与word匹配的第一个pattern选择性执行command-list。如果shell的nocasematch选项（查看4.3.2 shopt内置命令的详细内容）开启，匹配将忽略字母字符的大小写。'|'分割多个pattern, 而')'操作符表示pattern列表终止。pattern列表和其关联的command-list被称为子句。

每个子句必须以';;', ';&', 或';;&'之一结束。在尝试匹配之前，word会经历波浪号扩展，参数扩展，命令替换，算术运算扩展，和引用删除。每一个pattern也会经历波浪号扩展，参数扩展，命令替换，算术运算扩展。

可以有任何数量的case子句，它们必须以';;', ';&', 或';;&'之一结束。匹配到的第一个pattern决定了哪个command-list被执行。常见的用法是将'*'作为最后一个pattern来定义默认的子句，因为该pattern将始终匹配。

下面脚本中的`case`例子用来描述动物的一个有趣特征:

```bash

echo -n "Enter the name of an animal: "
read ANIMAL
echo -n "The $ANIMAL has "
case $ANIMAL in
  horse | dog | cat) echo -n "four";;
  man | kangaroo ) echo -n "two";;
  *) echo -n "an unknown number of";;
esac
echo " legs."
```

如果使用了';;'操作符，如果第一个pattern匹配到以后，则不会尝试继续匹配。使用';&'代替';;'，则会执行下一个子句关联的command-list（如果有）。使用';;&'代替';;'，则shell继续测试下一个子句中的pattern（如果有），并在成功的匹配上执行任何关联的命令列表。


如果没有patter被匹配，则返回状态为0，否则为执行的command-list的退出状态。

- select

`select`可以很容易的生成目录。它具有与`for`命令几乎相同的语法：

```bash

select name [in words …]; do commands; done
```

'in'后面的words列表被展开，生成一个项目列表。扩展后的words集合被打印在标准错误输出流上，每个前面都有一个数字。如果'in words'省略，则位置参数被打印，如同指定了'in "$@"'一样。然后显示PS3提示符，并从标准输入读取一行。如果该行由显示的words之一组成，则name会被设置为那个word。如果该行为空，则这些words和提示符会再一次显示。如果读到了EOF，则`select`命令完成。如果读到其他值，则会设置name为空。读到的行会被保存在REPLY变量中。

每次选择之后，commands会被执行，直到`break`命令被执行，此时`select`命令完成。

下面是一个允许用户从当前目录中选择文件名，并显示所选文件的名称和索引的例子。

```bash

select fname in *;
do
    echo you picked $fname \\($REPLY\\)
    break;
done
```

- ((...))

```bash

(( expression ))
```

算术运算表达式expression根据下面描述的规则（查看6.5 shell算术运算）计算。如果表达式的值不为零，返回状态为0，否则返回状态为1。这相当于

```bash

let "expression"
```

查看4.2 Bash内置命令，了解`let`内置命令的全部描述。

- [[...]]

```bash

[[ expression ]]
```

根据条件表达式expression的计算结果返回0或1的状态。表达式由6.4 Bash条件表达式中描述的主要部分组成。[[和]]之间的词不执行词分割和文件名扩展。波浪号扩展，参数和变量扩展，算术运算扩展，命令替换，进程替换，以及引用删除会被执行。诸如'-f'的条件运算操作符以不带引号的方式，才能被识别。

当'<'和'>'与[[一起使用时，它是按照当前语言环境的字典排序。

当使用'=='和'!='操作符时，操作符右边的字符串被认为是一种pattern，并根据3.5.8.1 模式匹配中描述的规则进行匹配，就好像启用了extglob shell选项一样。'='操作符与'=='。如果开启了nocasematch选项（查看4.3.2 shopt内置命令的详细描述），匹配执行将忽视大小写。如果字符串匹配('==')或者不匹配('!=')模式，则返回0，否则返回1。模式的任何部分都可以被引用来强制被引用的部分以一个字符串的形式被匹配。

另外一个二进制操作符'=~'可用，它具有'=='和'!='同样的优先级。当它使用是，操作符右边的字符串被认为是一个扩展的正则表达式，并进行相应的匹配（如在regex3中）。如果字符串与模式匹配，返回值为0，否则返回1。如果正则表达式在语法上不正确，条件表达式的返回值为2。如果开启了nocasematch选项（查看4.3.2 shopt内置命令的详细描述），匹配执行将忽视大小写。模式的任何部分都可以被引用来强制被引用的部分以一个字符串的形式被匹配。正则表达式中的括号表达式必须仔细对待，因为正常引用的字符在括号之间会丢失它们的含义。如果模式存储在一个shell变量中，引用这个变量扩展会强制整个模式以一个字符串的形式被匹配。正则表达式中括号子表达式匹配的子字符串会被存储在BASH_REMATCH变量中。BASH_REMATCH中索引为0的元素是与整个正则表达式匹配的字符串部分。BASH_REMATCH中索引为n的元素是匹配第n个括号子表达式的字符串部分。

例如，下面的代码将匹配存储（在shell变量line中）的一行，它是包含任意数量（包括0个）的空白字符，0个或者1个'a'，然后后接一个'b'的序列。

```bash

[[ $line =~ [[:space:]]*(a)?b ]]
```

这意味着，这意味着像'aab'和'aaaaaab'这样的值将会匹配，在其值中的任何地方包含一个“b”的行将匹配。

将正则表达式存储在shell变量中通常是避免引用shell特殊字符问题的有用方法。有时很难不用引号来表达正则表达式，或很难在注意shell的引用删除的同时跟踪正则表达式使用的引用。使用变量来存储模式可以减少这些问题。例如，下面的这个例子相当于上面的。

```bash

patter='[[:space:]]*(a)?b'
[[ $line =~ $pattern ]]
```

如果你想要匹配正则表达式语法的特殊字符，必须引用它来消除其特殊含义。这意味着模式'xxx.txt'中，'.'匹配字符串中的任何字符（它在正则表达式中的特殊含义），但是在模式'"xxx.txt"'中，它仅匹配'.'字符。shell程序员应该特别注意反斜杆，因为shell和正则表达式都使用它来消除后面字符的特殊含义。下面两组命令是不相等的:

```bash

pattern='\.'
[[ . =~ $pattern ]]
[[ . =~ \. ]]

[[ . =~ "$pattern" ]]
[[ . =~ '\.' ]]
```

第一组代码两个匹配都成功， 但是第二组都失败，因为第二组的两个反斜杆都是匹配的模式的一部分。在第一组的两个例子中，反斜杆消除了'.'的特殊含义，因此匹配字符'.'。如果第一个例子中字符串不是'.'，而是其他字符，比如说'a'，那么patter将不会被匹配，因为模式中被引用的'.'已经失去了它匹配任何单个字符的特殊含义。

expression可以使用以下运算符组合，按优先级顺序列出：

```bash

( expression )
```

返回表达式的值。这可以用于覆盖运算符的正常优先级。

```bash

! expression
```

如果expression为假，那么它为真

```bash

expression1 && expression2
```

如果expression1和expression2都为真，那么它为真

```bash

expression1 || expression2
```

如果expression1或expression2为真，那么它为真

#### 3.2.4.3 分组命令

bash提供两种方式来组合要作为一个单元执行的命令列表。当命令分组时，重定向可能会应用于整个命令列表。例如，列表中的所有命令的输出可能被重定向到单个流中。

- ()

```bash

( list )
```

将命令列表放在括号中，会创建一个子shell环境（查看3.7.1 命令执行环境），里面中的命令都在改子shell中执行。由于列表在子shell中执行，在子shell完成以后，变量赋值不会受影响。

例如（翻译者添加，帮助理解）:

```bash

declare -i i=1

( (( i++ )); echo $i )

# 输出为2

echo $i

# 输出为1
```

- {}

```bash

{ list; }
```

将命令列表放在大括号中，列表中的命令会在当前shell中执行。不会创建子shell。list后面的逗号（或换行符）是必需的。

除了创建子shell，由于历史的原因，这两种结构之间还存在微妙的差异。大括号是保留字，因此必须用空白或者其他shell元字符把list与它们隔开。括号是操作符，会被shell识别为分割token，即使它与list没有被空白隔开。

### 3.2.5 协进程

协进程是在shell命令前加上`coproc`保留字。协进程会在子shell中异步执行，就如同在命令后面加上了'&'控制符一样，并在执行的shell和协进程之间建立一个双向管道。

协进程的格式如下

```bash

coproc [NAME] command [redirections]
```

这会创建一个名为NAME的协进程。如果NAME没有指定，默认是COPROC。如果command是简单命令（查看3.2.1 简单命令），不得提供NAME。否则，它会被认为是命令的第一个词。

当协进程执行时，shell会在当前的shell上下文中创建一个名为NAME的数组变量。命令的标准输出通过管道连接到执行shell中的文件描述符，该文件描述符分配给NAME[0]。命令的标准输出通过管道连接到执行shell中的文件描述符，该文件描述符分配给NAME[1]。该管道在命令指定的任何重定向（查看3.6 重定向）之前创建。这些文件描述符可以使用标准词扩展来作为shell命令和重定向的参数。这些文件描述符在子shell中不可用。

shell生成执行协进程的进程ID可用作变量NAME_PID的值。`wait`内建命令可以用于等待协处理协进程。

由于协进程作为异步命令创建，所以`coproc`命令始终返回成功。协进程的返回状态是command的退出状态。

### 3.2.6 GNU并行

3.3 shell函数
-------------

3.4 shell参数
-------------

参数是存储值的实体。它可以是一个名称，数字，或下面列出来的特殊字符。变量是一个有名称标识的参数。变量有一个值及零个或多个属性。属性是通过`declare`内置命令分配的（查看4.2 Bash内置命令查看`declare`的描述）。

如果参数分配了值，那么它就被设置了。空字符串是一个有效的值。一旦变量被设置，它仅可通过内置命令`unset`来删除。

变量可以通过下面语句的形式来赋值

```bash

name=[value]
```

如果value没有给定，这个变量会被分配一个空字符串。 所有值包括波浪号扩展，参数和变量扩展，命令替换，算术扩展，和引用输出(详细如下)。如果变量设置了整数属性，那么即使不使用$((...))扩展，变量的值也会被作为算术表达式进行计算（查看3.55 算术扩展）。词分割不会被执行，除了下面解释的"$@"。文件名扩展不执行。赋值语句也可以以参数的形式出现在`alias`, `declare`, `typeset`, `export`, `readonly`和`local`内置命令(声明命令)。当在POSIX模式下(查看6.11 Bash POSIX模式)，这些内置命令也可以出现在内置命令`command`的一个或多个实例之后的命令中并保留这些赋值语句属性。

在赋值语句将一个值分配给shell变量或者数组索引(查看6.7 数组)，'+='操作符用于附加或者加到该变量的前一个值。它包含如接受赋值语句的`declare`内置命令（声明命令）的参数。当将'+ ='应用于已设置整数属性的变量时，将值作为算术表达式计算，并添加到变量的当前值中，该值也被计算。当将'+='应用于复合赋值（查看6.7 数组）的数组变量时，变量的值不是未设置的（因为它使用了'='），新值将插入到数组（索引数组）的最大索引值之后， 或作为附加键值对添加到关联数组中。当它应用于字符串型变量时，值将被扩展并附加到该变量的值。

使用带-n选项内置命令`declare`或`local`命令（查看4.2 Bash内置命令）为变量分配'nameref'属性来创建一个nameref, 或引用另一个变量。它允许变量被间接操作。无论nameref变量被引用，被分配，被删除，或属性被修改(除了使用或修改nameref属性本身)，该操作实际上是对nameref变量值指定变量的操作。nameref常用于函数内部来引用以参数传递给函数的变量。例如，如果将变量名作为第一个参数传递给函数，则运行

```bash

declare -n ref=$1
```

函数内部创建一个nameref变量ref，其值是第一个参数的变量名。引用和给ref赋值，或改变它的属性，被视为是对$1的操作。

如果for循环中的控制变量具有nameref属性，列表可以是一个shell变量列表， 并且当循环执行时，将顺序的为列表中的每个元素建立名称引用。数组变量不能被分配nameref属性。然而nameref变量可以引用数组变量和下标数组变量。nameref可以使用内置命令`unset`（查看4.1 Bourne Shell内置命令）的-n选项删除。否则，如果不加-n选项，被nameref变量引用的变量也将会被删除。

### 3.4.1 位置参数

位置参数是除了0以外的一个或者多个数字表示的参数。位置参数在shell的参数被调用时分配，并且可以使用`set`内置命令重新分配。位置参数N可以以${N}的形式引用，当N为单个数字时可以简写为$N。位置参数不能分配给赋值语句。内置命令`set`和`shift`用于设置和删除它们（查看4 shell内置命令）。当shell函数执行时，位置参数会被临时替换（查看3.3 shell函数）。

当位置参数由多个单个数字组成时，它必须用大括号括起来。

### 3.4.2 特殊参数

shell有几个特殊参数。这些参数只能被引用，不允许被赋值。

- \*

($*) 从第一个开始展开位置参数。当扩展不在双引号内，每个位置参数扩展为一个单独的词。在该参数执行的地方，这些位置参数将进一步的词分割和路径名扩展。当扩展在双引号内，它将被扩展为以特殊变量IFS的第一个字符分割的每个参数的值的单独词。也就是说，"$*"相当于"$1c$2c..."，其中c是变量IFS值的第一个字符。如果IFS没有设置，那么参数会被空白分割。如果IFS为空，会在没有中间分隔器的情况下连接参数。

- @

($@) 从第一个开始展开位置参数。当扩展在双引号内时，每个位置参数扩展为一个单独的词。也就是说，"$@" 相当于"$1" "$2" ...。如果元素内发生双引号扩展，第一个参数的扩展与原始单词的开始部分相结合， 最后一个参数的扩展与元素单词的最后部分相结合。当没有位置参数时，"$@"和$@被扩展为空（即它们被移除）。

- \#

($#) 扩展为位置参数的个数

- ?

($?) 扩展为最近执行的前台管道的退出状态。

- \-

($-, 连字符) 扩展为调用时指定的当前选项标志，有`set`内置命令或者由shell本身设置的选项标志(例如 -i 选项)。

- $

($$) 扩展为shell的进程ID。在()子shell中，它扩展为调用shell的进程ID，而不是子shell。

- !

($!) 扩展为最近置于后台执行的Job进程ID，无论这个Job是通过异步命令还是内置的`bg`命令(查看 7.2 Job控制内置命令)。

- 0

($0) 扩展为shell的名称或者shell脚本的名称。这是在shell初始化的时候设置的。如果Bash是被shell脚本调用(查看 3.8 shell脚本)，$0表示这个脚本的名称。如果Bash是以-c选项启动(查看 6.1 调用Bash)，那么$0被设置为执行字符串后的第一个参数，如果它存在。否则，它被设置为由参数0给出的用于调用Bash的文件名。

- _

($_, 下划线) 在shell启动时，设置为用于调用正在环境或参数列表中传递的shell或shell脚本的绝对路径名。然后，扩展后，扩展为上一个命令的最后一个参数。还设置为用于调用执行并放置在导出到该命令的环境中的每个命令的完整路径名。检查邮件时，此参数保存邮件文件的名称。


3.5 shell扩展
-------------

3.6 重定向
----------

3.7 执行命令
------------

3.8 shell脚本
-------------
